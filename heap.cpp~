#! /usr/local/bin/cxx

    /* a test for a handle object
     */

#include <stdlib.h>

#ifndef Matthewfl_heap_PointersListSize
#define Matthewfl_heap_PointersListSize 30
#endif

namespace matthewfl {
  namespace heap {
    namespace Private {
      template <typename Size> int _real_PointerCompair (void * P1, void * P2) {
	Size _p1 = reinterpret_cast<Size>(P1);
	Size _p2 = reinterpret_cast<Size>(P2);
	return _p1 - _p2;
      }
      int PointerCompair (void * P1, void * P2) {
	if(sizeof(void*) == 8) {
	  return _real_PointerCompair<long> (P1, P2);
	}
	return 0;
      }
      class Pointers {
      private:
	void * pointers[Matthewfl_heap_PointersListSize];
	unsigned char freePointers;
	void swap (Pointers &p) {
	  /*void * tempPoint[Matthewfl_heap_PointersListSize];// = p.pointers;
	  unsigned char tempFree = p.freePointers;
	  p.pointers = pointers;
	  p.freePointers = freePointers;
	  pointers = tempPoint;
	  freePointers = tempFree;*/
	  Pointers tmp = p;
	  p = *this;
	  *this = tmp;
	}
	Pointers * next;
	void destroySelf () {
	  if(next != NULL) {
	    swap(*next);
	    Pointers * temp = next;
	    next = temp->next;
	    delete temp;
	  }
	}
      public:
	Pointers (): freePointers(Matthewfl_heap_PointersListSize), next(NULL) {
	  for(unsigned char a = 0; a < Matthewfl_heap_PointersListSize; a++)
	    pointers[a] = NULL;
	}
	void * findPointer () {
	  if(freePointers <= 0) { // no more space
	    if (next == NULL) next = new Pointers;
	    return next->findPointer();
	  }else if(freePointers == Matthewfl_heap_PointersListSize && next != NULL) { // delete self
	    destroySelf();
	    return findPointer();
	  }
	  // give it a pointer
	  for(unsigned char a = 0; a < Matthewfl_heap_PointersListSize; a++) {
	    if(pointers[a] == NULL) {
	      freePointers--;
	      pointers[a] = (void*)1; // do not let it give it out again if not used
	      return pointers[a];
	    }
	  }
	  
	}
	void update () { // update the amount of free space
	  freePointers = 0;
	  for(unsigned int a = 0; a < Matthewfl_heap_PointersListSize; a++) {
	    if(pointers[a] == NULL)
	      freePointers++;
	  }
	  if(Matthewfl_heap_PointersListSize == freePointers) {
	    destroySelf();
	    update();
	  }
	  if(next != NULL)
	    next->update();
	}
      };
      class Manager {
      public:
	static short counter;
	static Pointers * headPointerNode;
      public:
	static bool _initialized;
	static bool init () {
	  if(Manager::_initialized) return true;
	  counter = 0;
	  Manager::headPointerNode = new Pointers;
	  _initialized = true;
	  return true;
	}
	static void * getPointer () {
	  counter++;
	  return headPointerNode->findPointer();
	}
      };
      bool Manager::_initialized = false;
      Pointers * Manager::headPointerNode;// = NULL;
      short Manager::counter;// = 0;
    } // namespace Private
    template <typename Type> class Handle {
    private:
      Type ** location;
      void init () {
	Private::Manager::init();
	location = reinterpret_cast<Type**> (Private::Manager::getPointer());
      }
    public:
      Handle (Type * t) {
	init();
	*location = t;
      }
      Handle (Handle<Type> &h) {
	location = h.location;
      }
      Type & operator * () { return **location; }
      inline Type & operator -> () { return operator*(); }
      Type * operator = (Type * d) { return *location = d; };
      void operator delete (void * _d) { 
	Handle<Type> * d = reinterpret_cast<Handle<Type> > (_d); 
      delete *d->location; *d->location = NULL; d->location = NULL; }
      Type * getLocation () { return *location; }
    };
  }// namespace heap

} // namespace matthewfl

#include <iostream>
using namespace std;

using matthewfl::heap::Handle;
int main (int argc, char * argv[]) {
  cout << "running ";
  
}
